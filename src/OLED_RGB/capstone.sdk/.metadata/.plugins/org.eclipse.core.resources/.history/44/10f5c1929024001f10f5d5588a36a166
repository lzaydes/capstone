/******************************************************************************/
/*                                                                            */
/* basic_example.c -- Demo project for the PmodJSTK2 IP                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Author: Samuel Lowe`                                                       */
/* Copyright 2016, Digilent Inc.                                              */
/*                                                                            */
/******************************************************************************/
/* File Description:                                                          */
/*                                                                            */
/* This demo reads the calibrated data from the PmodJSTK2 and prints the X    */
/* and Y values while mapping the axis to the LED. If the buttons on the      */
/* JSTK2 are pressed, the LED will turn green                                 */
/*                                                                            */
/* Data can be received with a serial terminal application connected to your  */
/* board and configured to use the appropriate baud rate below.               */
/*                                                                            */
/******************************************************************************/
/* Revision History:                                                          */
/*                                                                            */
/*    06/27/2016(SamL):     Created                                           */
/*    11/01/2017(atangzwj): Validated for Vivado 2016.4                       */
/*    01/13/2018(atangzwj): Validated for Vivado 2017.4                       */
/*                                                                            */
/******************************************************************************/
/* Baud Rates:                                                                */
/*                                                                            */
/* Microblaze: 9600 or what was specified in UARTlite core                    */
/* Zynq: 115200                                                               */
/*                                                                            */
/******************************************************************************/

#include "PmodOLEDrgb.h"
#include "PmodJSTK2.h"
#include "sleep.h"
#include "xil_cache.h"
#include "xil_printf.h"
#include "xgpio.h"

#ifdef __MICROBLAZE__
#define CPU_CLOCK_FREQ_HZ (XPAR_CPU_CORE_CLOCK_FREQ_HZ)
#else
#define CPU_CLOCK_FREQ_HZ (XPAR_PS7_CORTEXA9_0_CPU_CLK_FREQ_HZ)
#endif

#define GPIO_DEVICE_ID  XPAR_GPIO_0_DEVICE_ID
#define BUTTON_CHANNEL 1  // Channel for the buttons
#define TOP_BUTTON_MASK 0x01

PmodOLEDrgb screen;
PmodJSTK2 js1, js2;
XGpio sw;

int screenOffsetX, screenOffsetY = 0;

_Bool darkMode = 0;
_Bool prev_mode = 0;
_Bool startNewLine = 1;

u8 rgbUserFont[] = {
   0x00, 0x04, 0x02, 0x1F, 0x02, 0x04, 0x00, 0x00, // 0x00
   0x0E, 0x1F, 0x15, 0x1F, 0x17, 0x10, 0x1F, 0x0E, // 0x01
   0x00, 0x1F, 0x11, 0x00, 0x00, 0x11, 0x1F, 0x00, // 0x02
   0x00, 0x0A, 0x15, 0x11, 0x0A, 0x04, 0x00, 0x00, // 0x03
   0x07, 0x0C, 0xFA, 0x2F, 0x2F, 0xFA, 0x0C, 0x07  // 0x04
}; // This table defines 5 user characters, although only one is used

void init();
void EnableCaches();
void DisableCaches();

void get_state(PmodJSTK2 joystick, int* x, int* y, _Bool* jpressed, _Bool* tpressed);
void init_oled();
void init_joysticks();
void oled_reset();
void switch_light_mode();
void draw(int x, int y);
void check_light_mode();
void shift_screen(int dx, int dy);
void draw_line(int x0, int y0, int x1, int y1);
void init_xgpio();
void erase(int dx, int dy);
void snapshot();
void display_reset_screen();

void init_universe();

int prev_x = -1, prev_y = -1;

u32 universe[OLEDRGB_WIDTH * 2][OLEDRGB_HEIGHT * 2];

u32 draw_color = 0x0;
u32 erase_color = 0xFFFF;

void display_coords(PmodJSTK2 j1, PmodJSTK2 j2);

int main() {
   init();
   xil_printf("running...\n");

   while(1)
   {
	   check_light_mode();

	   // Check if reset button pressed
	  if (XGpio_DiscreteRead(&sw, BUTTON_CHANNEL) & TOP_BUTTON_MASK)
	  {
		  display_reset_screen();
		  while (XGpio_DiscreteRead(&sw, BUTTON_CHANNEL) & TOP_BUTTON_MASK) { continue; }
		  oled_reset();
	  }
	  else
		  display_coords(js1, js2);

   }
   return 0;
}

void get_state(PmodJSTK2 joystick, int* x, int* y, _Bool* jpressed, _Bool* tpressed)
{
	 JSTK2_Position position;
	 JSTK2_DataPacket rawdata;

	position = JSTK2_getPosition(&joystick);

    rawdata = JSTK2_getDataPacket(&joystick);

    x = position.YData;
    y = position.XData;
    jpressed = (rawdata.Jstk != 0);
    tpressed = (rawdata.Trigger != 0);
}

void init_oled() {
   EnableCaches();
   OLEDrgb_begin(&screen, XPAR_PMODOLEDRGB_0_AXI_LITE_GPIO_BASEADDR,
         XPAR_PMODOLEDRGB_0_AXI_LITE_SPI_BASEADDR);

   char ch;
   for (ch = 0; ch < 5; ch++) {
         OLEDrgb_DefUserChar(&screen, ch, &rgbUserFont[ch * 8]);
      }

      OLEDrgb_SetCursor(&screen, 2, 1);
      OLEDrgb_PutString(&screen, "CS152B"); // Default color (green)
      OLEDrgb_SetCursor(&screen, 4, 4);
      OLEDrgb_SetFontColor(&screen, OLEDrgb_BuildRGB(0, 0, 255)); // Blue font
      OLEDrgb_PutString(&screen, "etch a");

      OLEDrgb_SetFontColor(&screen, OLEDrgb_BuildRGB(200, 200, 44));
      OLEDrgb_SetCursor(&screen, 1, 6);
      OLEDrgb_PutChar(&screen, 4);

      OLEDrgb_SetFontColor(&screen, OLEDrgb_BuildRGB(200, 12, 44));
      OLEDrgb_SetCursor(&screen, 5, 6);
      OLEDrgb_PutString(&screen, "sketch");
      OLEDrgb_PutChar(&screen, 0);

      //sleep(5); // Wait 5 seconds

      oled_reset();
}

void init_joysticks()
{
	JSTK2_begin(
	      &js1,
	      XPAR_PMODJSTK2_0_AXI_LITE_SPI_BASEADDR,
	      XPAR_PMODJSTK2_0_AXI_LITE_GPIO_BASEADDR
	   );

	JSTK2_begin(
		      &js2,
		      XPAR_PMODJSTK2_1_AXI_LITE_SPI_BASEADDR,
		      XPAR_PMODJSTK2_1_AXI_LITE_GPIO_BASEADDR
		   );

	   // Set inversion register to invert only the Y axis
	   JSTK2_setInversion(&js1, 1, 1);
	   JSTK2_setInversion(&js2, 0, 0);
}

void init()
{
	init_universe();
	init_oled();
	init_joysticks();
	init_xgpio();
}

void display_reset_screen()
{
	for (int i = 0; i < OLEDRGB_WIDTH; i++)
			for (int j = 0; j < OLEDRGB_HEIGHT; j++)
				OLEDrgb_DrawPixel(&screen, i, j, OLEDrgb_BuildRGB(0, 0, 0));

	OLEDrgb_SetFontColor(&screen, OLEDrgb_BuildRGB(255, 255, 255));
	OLEDrgb_SetFontBkColor(&screen, OLEDrgb_BuildRGB(0, 0, 0));
	OLEDrgb_PutString(&screen, "RESETTING...");
}

void display_coords(PmodJSTK2 j1, PmodJSTK2 j2)
{
	JSTK2_Position p1, p2;
	JSTK2_DataPacket r1, r2;

	  p1 = JSTK2_getPosition(&j1);
	  p2 = JSTK2_getPosition(&j2);

	  // Get button states
	  r1 = JSTK2_getDataPacket(&j1);
	  r2 = JSTK2_getDataPacket(&j2);

	  xil_printf(
		 "X_L:%d\tY_L:%d\r\n",
		 p1.YData,
		 p1.XData
	  );
	  xil_printf(
	  		 "X_R:%d\tY_R:%d\r\n\n\n",
	  		 p2.YData,
	  		 p2.XData
	  	  );

	  // Set led from btns and axis
	  if (r1.Jstk != 0 || r1.Trigger != 0) {
		 JSTK2_setLedRGB(&j1, 0, 255, 0);
	  } else {
		 JSTK2_setLedRGB(&j1, p1.YData, 0, p1.XData);
	  }

	  if (r2.Jstk != 0 || r2.Trigger != 0) {
	 		 JSTK2_setLedRGB(&j2, 0, 255, 0);
	 	  } else {
	 		 JSTK2_setLedRGB(&j2, p2.YData, 0, p2.XData);
	 	  }

	  while (r2.Jstk)
	  {
		  int x_coord_draw = (int)((p2.YData / 255.0) * OLEDRGB_WIDTH);
		  int y_coord_draw = (int)(((255 - p2.XData) / 255.0) * OLEDRGB_HEIGHT);

		  draw(x_coord_draw, y_coord_draw);
		  prev_x = x_coord_draw;
		  prev_y = y_coord_draw;
	  }
	  startNewLine = 1;

		  // Check if reset button pressed
		  if (XGpio_DiscreteRead(&sw, BUTTON_CHANNEL) & TOP_BUTTON_MASK)
		  {
			  oled_reset();
		  }

	  // screen shifting with left joystick
	  while (r1.Jstk)
	  {
		  int x_coord_shift = (int)((p1.YData / 255.0) * OLEDRGB_WIDTH);
		  int y_coord_shift = (int)(((255 - p1.XData) / 255.0) * OLEDRGB_HEIGHT);

		  if (p1.XData != 128 || p1.YData != 128)
		  erase(x_coord_shift, y_coord_shift);
	  }
}

void draw(int x, int y)
{
	if (prev_x == -1 || startNewLine)
		OLEDrgb_DrawPixel(&screen, x, y,  draw_color);
	else
		{
			OLEDrgb_DrawLine(&screen, x, y, prev_x, prev_y, draw_color);
			startNewLine = 0;
		}
}

void oled_reset()
{
	for (int i = 0; i < OLEDRGB_WIDTH; i++)
	{
		for (int j = 0; j < OLEDRGB_HEIGHT; j++)
		{
			OLEDrgb_DrawPixel(&screen, i, j, erase_color);
		}
	}
}

void switch_light_mode()
{
	u32 temp;
	temp = draw_color;
	draw_color = erase_color;
	erase_color = temp;

	for (int i = 0; i < OLEDRGB_WIDTH; i++)
			for (int j = 0; j < OLEDRGB_HEIGHT; j++)
				OLEDrgb_DrawPixel(&screen, i, j, erase_color);
}

void check_light_mode()
{
	_Bool curr_mode = XGpio_DiscreteRead(&sw, 1) & 0x02;
	if (curr_mode != prev_mode)
		switch_light_mode();
	prev_mode = curr_mode;
}

void snapshot()
{
	for (int x = 0; x < OLEDRGB_WIDTH; x++)
		for (int y = 0; y < OLEDRGB_HEIGHT; y++)
			universe[screenOffsetX + x][screenOffsetY + y] = OLEDrgb_GetPixel(&screen, x, y);
}

void erase(int x, int y)
{
	int radius = 4;

	for (int i = x - 4; i <= x + 4; i++)
	{
		for (int j = y - 4; j <= y + 4; j++)
			OLEDrgb_DrawPixel(&screen, i, j, erase_color);
	}
}

void init_xgpio()
{
	int status;

	 status = XGpio_Initialize(&sw, GPIO_DEVICE_ID);
	if (status != XST_SUCCESS) {
		xil_printf("GPIO Initialization Failed\r\n");
		return XST_FAILURE;
	}

	// Set the direction for the buttons channel to input
	XGpio_SetDataDirection(&sw, BUTTON_CHANNEL, 0xFFFFFFFF);
}

void init_universe()
{
	for (int x = 0; x < OLEDRGB_WIDTH; x++)
			for (int y = 0; y < OLEDRGB_HEIGHT; y++)
				universe[x][y] = OLEDrgb_BuildRGB(255, 255, 255);
}

void cleanup() {
   DisableCaches();
}

void EnableCaches() {
#ifdef __MICROBLAZE__
#ifdef XPAR_MICROBLAZE_USE_ICACHE
   Xil_ICacheEnable();
#endif
#ifdef XPAR_MICROBLAZE_USE_DCACHE
   Xil_DCacheEnable();
#endif
#endif
}

void DisableCaches() {
#ifdef __MICROBLAZE__
#ifdef XPAR_MICROBLAZE_USE_DCACHE
   Xil_DCacheDisable();
#endif
#ifdef XPAR_MICROBLAZE_USE_ICACHE
   Xil_ICacheDisable();
#endif
#endif
}
